use std::{path::PathBuf, sync::Arc};

use alloy_consensus::SignableTransaction;
use alloy_primitives::{Address, B256, ChainId, keccak256};
use alloy_signer::{Signature, Signer, SignerSync, sign_transaction_with_chain_id};
use async_trait::async_trait;
use k256::{
    EncodedPoint,
    ecdsa::{self, VerifyingKey},
};

use cryptoki::{
    context::{CInitializeArgs, Pkcs11},
    mechanism::Mechanism,
    object::{Attribute, AttributeType, ObjectHandle},
    session::{Session, UserType},
    types::AuthPin,
};
use once_cell::sync::OnceCell;
use parking_lot::Mutex;
use tracing::instrument;

/// # PKCS #11 Hardware-Backed Ethereum Signer
///
/// `Pkcs11Signer` is an Ethereum‐compatible signer that forwards signing requests
/// to any device that exposes a [PKCS #11] interface—AWS CloudHSM, YubiHSM 2,
/// SoftHSM, Thales Luna, or a vendor-specific smart card.  The secret key never
/// leaves the hardware module; all ECDSA secp256k1 signatures are produced inside
/// the token and returned to the caller in canonical *low-s* form.
///
/// Internally the signer
///
/// 1. Loads the vendor’s PKCS #11 shared library once per process (*lazy-static*),
/// 2. Opens a read-write session on the first slot that contains a token,
/// 3. Logs in as a regular **Crypto User** (`UserType::User`) using the
///    `CLOUDHSM_PIN` (or the PIN you supply manually),
/// 4. Locates the public- and private-key objects via arbitrary `Attribute`s
///    (label, ID, class, …), and
/// 5. Caches the public key, derived address, and object handles for
///    zero-copy, lock-free reads.
///
/// Because the module speaks plain PKCS #11 it is agnostic to how the key was
/// created—imported, generated by the HSM, or wrapped/unwrapped elsewhere—as
/// long as it is an **EC secp256k1** key with the `CKA_SIGN` attribute set.
///
/// ## Sync **and** Async
///
/// `Pkcs11Signer` supports both the `Signer` (async)
/// *and* `SignerSync` traits.  The underlying HSM calls are blocking, so the
/// async methods simply run on the current thread; choose whichever style
/// integrates best with your codebase.
///
/// ## Configuration
///
/// ```no_run
/// use alloy_signer_pkcs11::{Pkcs11Signer, Pkcs11SignerConfig};
/// use alloy_primitives::ChainId;
/// use cryptoki::object::Attribute;
/// # fn main() -> anyhow::Result<()> {
/// let cfg = Pkcs11SignerConfig::new(
///     Attribute::Label("my-pub".into()),  // public key selector
///     0,                                  // take the first match
///     Attribute::Label("my-priv".into()), // private key selector
///     0,
///     std::env::var("CLOUDHSM_PIN")?.into(),
///     "/opt/cloudhsm/lib/libcloudhsm_pkcs11.so".into(),
///     0
/// );
///
/// let signer = Pkcs11Signer::new(cfg, Some(ChainId::from(1u64)))?;
/// println!("signing as: {:?}", signer.address());
/// # Ok(()) }
/// ```
#[derive(Clone)]
pub struct Pkcs11Signer {
    session: Arc<Mutex<Session>>,
    pk_handle: ObjectHandle,
    pubkey: VerifyingKey,
    address: Address,
    chain_id: Option<ChainId>,
}

impl std::fmt::Debug for Pkcs11Signer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Pkcs11Signer")
            .field("pubkey", &hex::encode(self.pubkey.to_sec1_bytes()))
            .field("address", &self.address)
            .field("chain_id", &self.chain_id)
            .finish()
    }
}

static PKCS11: OnceCell<Pkcs11> = OnceCell::new();

#[derive(Debug, Clone)]
pub struct Pkcs11SignerConfig {
    pub public_key_attribute: Attribute,
    pub public_key_slot: usize,
    pub private_key_attribute: Attribute,
    pub private_key_slot: usize,
    pub cloud_hsm_pin: AuthPin,
    pub pkcs11_lib_path: PathBuf,
    pub token_slot: usize,
}

impl Pkcs11SignerConfig {
    pub fn new(
        public_key_attribute: Attribute,
        public_key_slot: usize,
        private_key_attribute: Attribute,
        private_key_slot: usize,
        cloud_hsm_pin: AuthPin,
        pkcs11_lib_path: PathBuf,
        token_slot: usize,
    ) -> Self {
        Self {
            public_key_attribute,
            public_key_slot,
            private_key_attribute,
            private_key_slot,
            cloud_hsm_pin,
            pkcs11_lib_path,
            token_slot,
        }
    }

    pub fn from_env_with_defaults(
        public_key_label: &str,
        private_key_label: &str,
        pkcs11_lib_path: PathBuf,
    ) -> Self {
        Self {
            public_key_attribute: Attribute::Label(public_key_label.into()),
            public_key_slot: 0,
            private_key_attribute: Attribute::Label(private_key_label.into()),
            private_key_slot: 0,
            cloud_hsm_pin: AuthPin::new(
                std::env::var("CLOUDHSM_PIN").expect(
                    "CLOUDHSM_PIN not found -- `export CLOUDHSM_PIN=\"CryptoUser:YourPass\"`",
                ),
            ),
            pkcs11_lib_path,
            token_slot: 0,
        }
    }
}

/// Errors thrown by [`Pkcs11Signer`].
#[derive(Debug, thiserror::Error)]
pub enum Pkcs11SignerError {
    /// [`ecdsa`] error.
    #[error(transparent)]
    K256(#[from] ecdsa::Error),
    /// [`cryptoki`] error.
    #[error(transparent)]
    Pkcs11(#[from] cryptoki::error::Error),
    /// [`sec1`] error.
    #[error(transparent)]
    Sec1(#[from] sec1::Error),
    /// [`hex`](mod@hex) error.
    #[error(transparent)]
    Hex(#[from] hex::FromHexError),
    /// Thrown when the EC point format is incorrect or unexpected
    #[error("unexpected Ec-point format")]
    IncorrectEcPointFormat,
    /// Thrown when the public key is not found at a certain slot
    #[error("public key not found at slot {0}")]
    PublicKeyNotFound(usize),
    /// Thrown when the private key is not found at a certain slot
    #[error("private key not found at slot {0}")]
    PrivateKeyNotFound(usize),
}

impl Pkcs11Signer {
    pub fn new(
        config: Pkcs11SignerConfig,
        chain_id: Option<ChainId>,
    ) -> Result<Self, Pkcs11SignerError> {
        let pkcs11 = PKCS11.get_or_try_init(|| {
            let pkcs11 = Pkcs11::new(config.pkcs11_lib_path)?;
            pkcs11.initialize(CInitializeArgs::OsThreads)?;
            Ok::<_, cryptoki::error::Error>(pkcs11)
        })?;

        let slot = pkcs11.get_slots_with_token()?[config.token_slot];
        let session = pkcs11.open_rw_session(slot)?;

        session.login(UserType::User, Some(&config.cloud_hsm_pin))?;

        let pub_handles = session.find_objects(&[config.public_key_attribute])?;
        let pub_key = pub_handles
            .get(config.public_key_slot)
            .copied()
            .ok_or(Pkcs11SignerError::PublicKeyNotFound(config.public_key_slot))?;

        let ec_attr = session.get_attributes(pub_key, &[AttributeType::EcPoint])?;
        let der = match &ec_attr[0] {
            Attribute::EcPoint(point) => point.clone(),
            _ => return Err(Pkcs11SignerError::IncorrectEcPointFormat),
        };
        let address = address_from_ec_point(&der)?;
        let pubkey = verifying_key_ec_point(&der)?;

        let priv_handles = session.find_objects(&[config.private_key_attribute])?;
        let priv_key = priv_handles.get(config.private_key_slot).copied().ok_or(
            Pkcs11SignerError::PrivateKeyNotFound(config.private_key_slot),
        )?;

        Ok(Self {
            session: Arc::new(Mutex::new(session)),
            address,
            pk_handle: priv_key,
            chain_id,
            pubkey,
        })
    }

    /// Sign a message with the signers key
    pub fn sign_message<B: AsRef<[u8]>>(&self, msg: B) -> Result<Vec<u8>, Pkcs11SignerError> {
        let lock = self.session.lock();
        let out = lock.sign(&Mechanism::Ecdsa, self.pk_handle, msg.as_ref())?;
        drop(lock);
        Ok(out)
    }

    /// Sign a digest with this signer's key
    pub fn sign_digest(&self, digest: &B256) -> Result<ecdsa::Signature, Pkcs11SignerError> {
        let raw = self.sign_message(digest)?;
        let sig = ecdsa::Signature::from_slice(&raw)?;
        Ok(sig.normalize_s().unwrap_or(sig))
    }

    /// Sign a digest with this signer's key and applies EIP-155.
    #[instrument(err, skip(digest), fields(digest = %hex::encode(digest)))]
    pub fn sign_digest_inner(&self, digest: &B256) -> Result<Signature, Pkcs11SignerError> {
        let sig = self.sign_digest(digest)?;
        Ok(sig_from_digest_bytes_trial_recovery(
            sig,
            digest,
            &self.pubkey,
        ))
    }
}

#[cfg_attr(target_family = "wasm", async_trait(?Send))]
#[cfg_attr(not(target_family = "wasm"), async_trait)]
impl alloy_network::TxSigner<Signature> for Pkcs11Signer {
    fn address(&self) -> Address {
        self.address
    }

    #[inline]
    #[doc(alias = "sign_tx")]
    async fn sign_transaction(
        &self,
        tx: &mut dyn SignableTransaction<Signature>,
    ) -> alloy_signer::Result<Signature> {
        sign_transaction_with_chain_id!(self, tx, self.sign_hash(&tx.signature_hash()).await)
    }
}

#[cfg_attr(target_family = "wasm", async_trait(?Send))]
#[cfg_attr(not(target_family = "wasm"), async_trait)]
impl Signer for Pkcs11Signer {
    #[instrument(err)]
    #[allow(clippy::blocks_in_conditions)]
    async fn sign_hash(&self, hash: &B256) -> alloy_signer::Result<Signature> {
        self.sign_digest_inner(hash)
            .map_err(alloy_signer::Error::other)
    }

    #[inline]
    fn address(&self) -> Address {
        self.address
    }

    #[inline]
    fn chain_id(&self) -> Option<ChainId> {
        self.chain_id
    }

    #[inline]
    fn set_chain_id(&mut self, chain_id: Option<ChainId>) {
        self.chain_id = chain_id;
    }
}

impl SignerSync for Pkcs11Signer {
    #[inline]
    fn sign_hash_sync(&self, hash: &B256) -> alloy_signer::Result<Signature> {
        self.sign_digest_inner(hash)
            .map_err(alloy_signer::Error::other)
    }

    #[inline]
    fn chain_id_sync(&self) -> Option<ChainId> {
        self.chain_id
    }
}

alloy_network::impl_into_wallet!(Pkcs11Signer);

/// Recover an rsig from a signature under a known key by trial/error.
fn sig_from_digest_bytes_trial_recovery(
    sig: ecdsa::Signature,
    hash: &B256,
    pubkey: &VerifyingKey,
) -> Signature {
    let signature = Signature::from_signature_and_parity(sig, false);
    if check_candidate(&signature, hash, pubkey) {
        return signature;
    }

    let signature = signature.with_parity(true);
    if check_candidate(&signature, hash, pubkey) {
        return signature;
    }

    panic!("bad sig");
}

/// Makes a trial recovery to check whether an RSig corresponds to a known `VerifyingKey`.
fn check_candidate(signature: &Signature, hash: &B256, pubkey: &VerifyingKey) -> bool {
    signature
        .recover_from_prehash(hash)
        .map(|key| key == *pubkey)
        .unwrap_or(false)
}

/// Converts the EC-point of the key to an [Address]
fn address_from_ec_point(der: &[u8]) -> Result<Address, Pkcs11SignerError> {
    // 1.  DER-encoded OCTET STRING => skip the tag & length
    let (_, octet) = der.split_at(2);

    // 2.  First byte of the OCTET STRING is 0x04 (uncompressed prefix)
    if octet.len() != 65 || octet[0] != 0x04 {
        return Err(Pkcs11SignerError::IncorrectEcPointFormat);
    }
    let pubkey = &octet[1..]; // 64-byte X‖Y

    // 3. Take the last 20 bytes of keccak256
    let hash = keccak256(pubkey);
    Ok(Address::from_slice(&hash[12..]))
}

/// Converts the EC-point of the key to a [VerifyingKey]
fn verifying_key_ec_point(der: &[u8]) -> Result<VerifyingKey, Pkcs11SignerError> {
    // unwrap DER if present
    let sec1 = match der {
        [0x04, l, rest @ ..] if *l as usize == rest.len() => rest,
        _ => der,
    };

    // ensure 65-byte uncompressed point
    let sec1 = if sec1[0] == 0x04 && sec1.len() == 65 {
        sec1.to_vec()
    } else if sec1.len() == 64 {
        let mut buf = [0u8; 65];
        buf[0] = 0x04;
        buf[1..].copy_from_slice(sec1);
        buf.to_vec()
    } else {
        return Err(Pkcs11SignerError::IncorrectEcPointFormat);
    };

    let point = EncodedPoint::from_bytes(sec1)?;
    Ok(VerifyingKey::from_encoded_point(&point)?)
}

#[cfg(test)]
mod tests {
    use super::*;

    use alloy::signers::aws::AwsSigner;
    use alloy_consensus::{SignableTransaction, TxLegacy};
    use alloy_network::TxSigner;
    use alloy_primitives::{Address, TxKind};
    use alloy_signer::Signer;
    use aws_config::{BehaviorVersion, Region};

    fn hms_signer() -> Pkcs11Signer {
        let config = Pkcs11SignerConfig::from_env_with_defaults(
            "angstrom3-eth-public-key-test-meow",
            "angstrom3-eth-private-key-test-meow",
            PathBuf::from("/opt/cloudhsm/lib/libcloudhsm_pkcs11.so"),
        );
        Pkcs11Signer::new(config, Some(ChainId::from(1u64))).unwrap()
    }

    async fn kms_signer() -> AwsSigner {
        let mut cfg_builder = aws_config::load_defaults(BehaviorVersion::latest())
            .await
            .into_builder();
        cfg_builder.set_region(Some(Region::from_static("ap-northeast-1")));
        let cfg = cfg_builder.build();

        let client = aws_sdk_kms::Client::new(&cfg);

        let key_id = "534a7042-d225-4a8a-8494-3fb29c9c1617";
        AwsSigner::new(client, key_id.into(), Some(1))
            .await
            .unwrap()
    }

    #[tokio::test]
    async fn test_kms_equals() {
        dotenv::dotenv().ok();

        let hms_signer = hms_signer();
        let kms_signer = kms_signer().await;

        assert_eq!(hms_signer.address, Signer::address(&kms_signer));
        assert_eq!(hms_signer.pubkey, kms_signer.get_pubkey().await.unwrap());

        let mut tx = TxLegacy::default();
        tx.to = TxKind::Call(Address::random());

        let hsm_tx_sig0 = hms_signer.sign_transaction(&mut tx).await.unwrap();
        let kms_tx_sig0 = kms_signer.sign_transaction(&mut tx).await.unwrap();
        assert_eq!(
            hsm_tx_sig0
                .recover_from_prehash(&tx.signature_hash())
                .unwrap(),
            kms_tx_sig0
                .recover_from_prehash(&tx.signature_hash())
                .unwrap()
        );

        let hsm_tx_sig1 = hms_signer.sign_hash_sync(&tx.signature_hash()).unwrap();
        let kms_tx_sig1 = kms_signer.sign_hash(&tx.signature_hash()).await.unwrap();
        assert_eq!(
            hsm_tx_sig1
                .recover_from_prehash(&tx.signature_hash())
                .unwrap(),
            kms_tx_sig1
                .recover_from_prehash(&tx.signature_hash())
                .unwrap()
        );
    }
}
